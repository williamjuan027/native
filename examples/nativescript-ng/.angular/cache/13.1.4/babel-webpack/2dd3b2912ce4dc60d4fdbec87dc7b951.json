{
    "ast": null,
    "code": "import * as http from '../http';\nimport * as types from '../utils/types';\nimport { Trace } from '../trace';\nvar XMLHttpRequestResponseType;\n\n(function (XMLHttpRequestResponseType) {\n  XMLHttpRequestResponseType.empty = '';\n  XMLHttpRequestResponseType.text = 'text';\n  XMLHttpRequestResponseType.json = 'json';\n  XMLHttpRequestResponseType.blob = 'blob';\n  XMLHttpRequestResponseType.arraybuffer = 'arraybuffer';\n})(XMLHttpRequestResponseType || (XMLHttpRequestResponseType = {}));\n\nexport class XMLHttpRequest {\n  constructor() {\n    this.UNSENT = 0;\n    this.OPENED = 1;\n    this.HEADERS_RECEIVED = 2;\n    this.LOADING = 3;\n    this.DONE = 4;\n    this._responseType = '';\n    this._listeners = new Map();\n    this._readyState = this.UNSENT;\n  }\n\n  get upload() {\n    return this;\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n\n  get responseType() {\n    return this._responseType;\n  }\n\n  set responseType(value) {\n    if (value === XMLHttpRequestResponseType.empty || value in XMLHttpRequestResponseType) {\n      this._responseType = value;\n    } else {\n      throw new Error(`Response type of '${value}' not supported.`);\n    }\n  }\n\n  get responseText() {\n    if (this._responseType !== XMLHttpRequestResponseType.empty && this._responseType !== XMLHttpRequestResponseType.text) {\n      throw new Error(\"Failed to read the 'responseText' property from 'XMLHttpRequest': \" + \"The value is only accessible if the object's 'responseType' is '' or 'text' \" + `(was '${this._responseType}').`);\n    }\n\n    if (types.isFunction(this._responseTextReader)) {\n      return this._responseTextReader();\n    }\n\n    return '';\n  }\n\n  get response() {\n    if (this._responseType === XMLHttpRequestResponseType.empty || this._responseType === XMLHttpRequestResponseType.text) {\n      if (this._readyState !== this.LOADING && this._readyState !== this.DONE) {\n        return '';\n      } else {\n        return this._response;\n      }\n    } else {\n      if (this._readyState !== this.DONE) {\n        return null;\n      } else {\n        return this._response;\n      }\n    }\n  }\n\n  get status() {\n    return this._status;\n  }\n\n  get statusText() {\n    if (this._readyState === this.UNSENT || this._readyState === this.OPENED || this._errorFlag) {\n      return '';\n    }\n\n    return statuses[this._status];\n  }\n\n  _loadResponse(r) {\n    this._status = r.statusCode;\n    this._headers = r.headers;\n\n    this._setReadyState(this.HEADERS_RECEIVED);\n\n    this._setReadyState(this.LOADING);\n\n    this._responseTextReader = () => r.content.toString();\n\n    const contentType = this.getResponseHeader('Content-Type');\n    const mimeType = contentType && contentType.toLowerCase() || 'text/xml';\n    const finalMimeType = this._overrideMimeType || mimeType;\n\n    if (this._responseType === XMLHttpRequestResponseType.json) {\n      this._response = r.content.toJSON();\n    } else if (this._responseType === XMLHttpRequestResponseType.text || this._responseType === XMLHttpRequestResponseType.empty) {\n      this._response = this.responseText;\n    } else if (this._responseType === XMLHttpRequestResponseType.arraybuffer) {\n      this._response = r.content.toArrayBuffer();\n    } else if (this._responseType === XMLHttpRequestResponseType.blob) {\n      this._response = new Blob([r.content.toArrayBuffer()], {\n        type: finalMimeType\n      });\n    }\n\n    this.emitEvent('progress');\n    this._sendFlag = false;\n\n    this._setReadyState(this.DONE);\n  }\n\n  emitEvent(eventName, ...args) {\n    if (types.isFunction(this['on' + eventName])) {\n      this['on' + eventName](...args);\n    }\n\n    const handlers = this._listeners.get(eventName) || [];\n    handlers.forEach(handler => {\n      handler(...args);\n    });\n  }\n\n  _setReadyState(value) {\n    if (this._readyState !== value) {\n      this._readyState = value;\n      this.emitEvent('readystatechange');\n    }\n\n    if (this._readyState === this.DONE) {\n      this.emitEvent('load');\n      this.emitEvent('loadend');\n    }\n  }\n\n  _setRequestError(eventName, error) {\n    this._readyState = this.DONE;\n    this._response = error;\n    this.emitEvent('readystatechange');\n    this.emitEvent(eventName, error);\n    this.emitEvent('loadend');\n  }\n\n  addEventListener(eventName, handler) {\n    if (['abort', 'error', 'load', 'loadend', 'loadstart', 'progress', 'readystatechange'].indexOf(eventName) === -1) {\n      if (Trace.isEnabled()) {\n        Trace.write('XHR Event not supported: ' + eventName, Trace.categories.Debug, Trace.messageType.warn);\n      }\n    }\n\n    const handlers = this._listeners.get(eventName) || [];\n    handlers.push(handler);\n\n    this._listeners.set(eventName, handlers);\n  }\n\n  removeEventListener(eventName, toDetach) {\n    let handlers = this._listeners.get(eventName) || [];\n    handlers = handlers.filter(handler => handler !== toDetach);\n\n    this._listeners.set(eventName, handlers);\n  }\n\n  open(method, url, async, user, password) {\n    if (types.isString(method) && types.isString(url)) {\n      this._options = {\n        url: url,\n        method: method\n      };\n      this._options.headers = {};\n\n      if (types.isString(user)) {\n        this._options.headers['user'] = user;\n      }\n\n      if (types.isString(password)) {\n        this._options.headers['password'] = password;\n      }\n\n      this._setReadyState(this.OPENED);\n    }\n  }\n\n  abort() {\n    this._response = null;\n    this._responseTextReader = null;\n    this._headers = null;\n    this._status = null;\n\n    if (this._readyState === this.OPENED && this._sendFlag || this._readyState === this.HEADERS_RECEIVED || this._readyState === this.LOADING) {\n      this._errorFlag = true;\n      this._sendFlag = false;\n\n      this._setRequestError('abort');\n    }\n\n    if (this._readyState === this.DONE) {\n      this._readyState = this.UNSENT;\n    }\n  }\n\n  send(data) {\n    this._errorFlag = false;\n    this._response = null;\n    this._responseTextReader = null;\n    this._headers = null;\n    this._status = null;\n\n    if (this._readyState !== this.OPENED || this._sendFlag) {\n      throw new Error(\"Failed to execute 'send' on 'XMLHttpRequest': \" + \"The object's state must be OPENED.\");\n    }\n\n    if (types.isString(data) && this._options.method !== 'GET') {\n      //The Android Java HTTP lib throws an exception if we provide a\n      //a request body for GET requests, so we avoid doing that.\n      //Browser implementations silently ignore it as well.\n      this._options.content = data;\n    } else if (data instanceof FormData) {\n      this._options.content = data.toString();\n    } else if (data instanceof Blob) {\n      this.setRequestHeader('Content-Type', data.type);\n      this._options.content = Blob.InternalAccessor.getBuffer(data);\n    } else if (data instanceof ArrayBuffer) {\n      this._options.content = data;\n    }\n\n    this._sendFlag = true;\n    this.emitEvent('loadstart');\n    http.request(this._options).then(r => {\n      if (!this._errorFlag && this._sendFlag) {\n        this._loadResponse(r);\n      }\n    }).catch(e => {\n      this._errorFlag = true;\n      this._sendFlag = false;\n\n      this._setRequestError('error', e);\n    });\n  }\n\n  setRequestHeader(header, value) {\n    if (this._readyState !== this.OPENED || this._sendFlag) {\n      throw new Error(\"Failed to execute 'setRequestHeader' on 'XMLHttpRequest': \" + \"The object's state must be OPENED.\");\n    }\n\n    if (types.isString(header) && types.isString(value)) {\n      this._options.headers[header] = value;\n    }\n  }\n\n  getAllResponseHeaders() {\n    if (this._readyState < 2 || this._errorFlag) {\n      return '';\n    }\n\n    let result = '';\n\n    for (const i in this._headers) {\n      result += i + ': ' + this._headers[i] + '\\r\\n';\n    }\n\n    return result.substr(0, result.length - 2);\n  }\n\n  getResponseHeader(header) {\n    if (types.isString(header) && this._readyState > 1 && this._headers && !this._errorFlag) {\n      header = header.toLowerCase();\n\n      for (const i in this._headers) {\n        if (i.toLowerCase() === header) {\n          return this._headers[i];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  overrideMimeType(mime) {\n    if (this._readyState === this.LOADING || this._readyState === this.DONE) {\n      throw new Error(\"Failed to execute 'overrideMimeType' on 'XMLHttpRequest': \" + 'MimeType cannot be overridden when the state is LOADING or DONE.');\n    }\n\n    this._overrideMimeType = mime;\n  }\n\n}\nconst statuses = {\n  100: 'Continue',\n  101: 'Switching Protocols',\n  200: 'OK',\n  201: 'Created',\n  202: 'Accepted',\n  203: 'Non - Authoritative Information',\n  204: 'No Content',\n  205: 'Reset Content',\n  206: 'Partial Content',\n  300: 'Multiple Choices',\n  301: 'Moved Permanently',\n  302: 'Found',\n  303: 'See Other',\n  304: 'Not Modified',\n  305: 'Use Proxy',\n  307: 'Temporary Redirect',\n  400: 'Bad Request',\n  401: 'Unauthorized',\n  402: 'Payment Required',\n  403: 'Forbidden',\n  404: 'Not Found',\n  405: 'Method Not Allowed',\n  406: 'Not Acceptable',\n  407: 'Proxy Authentication Required',\n  408: 'Request Timeout',\n  409: 'Conflict',\n  410: 'Gone',\n  411: 'Length Required',\n  412: 'Precondition Failed',\n  413: 'Request Entity Too Large',\n  414: 'Request - URI Too Long',\n  415: 'Unsupported Media Type',\n  416: 'Requested Range Not Satisfiable',\n  417: 'Expectation Failed',\n  500: 'Internal Server Error',\n  501: 'Not Implemented',\n  502: 'Bad Gateway',\n  503: 'Service Unavailable',\n  504: 'Gateway Timeout',\n  505: 'HTTP Version Not Supported'\n};\nexport class FormData {\n  constructor() {\n    this._data = new Map();\n  }\n\n  append(name, value) {\n    this._data.set(name, value);\n  }\n\n  toString() {\n    const arr = new Array();\n\n    this._data.forEach(function (value, name, map) {\n      arr.push(`${encodeURIComponent(name)}=${encodeURIComponent(value)}`);\n    });\n\n    return arr.join('&');\n  }\n\n}\nexport class Blob {\n  constructor(chunks = [], opts = {}) {\n    this[Symbol.toStringTag] = 'Blob';\n    const dataChunks = [];\n\n    for (const chunk of chunks) {\n      if (chunk instanceof Blob) {\n        dataChunks.push(chunk._buffer);\n      } else if (typeof chunk === 'string') {\n        const textEncoder = new TextEncoder();\n        dataChunks.push(textEncoder.encode(chunk));\n      } else if (chunk instanceof DataView) {\n        dataChunks.push(new Uint8Array(chunk.buffer.slice(0)));\n      } else if (chunk instanceof ArrayBuffer || ArrayBuffer.isView(chunk)) {\n        dataChunks.push(new Uint8Array(ArrayBuffer.isView(chunk) ? chunk.buffer.slice(0) : chunk.slice(0)));\n      } else {\n        const textEncoder = new TextEncoder();\n        dataChunks.push(textEncoder.encode(String(chunk)));\n      }\n    }\n\n    const size = dataChunks.reduce((size, chunk) => size + chunk.byteLength, 0);\n    const buffer = new Uint8Array(size);\n    let offset = 0;\n\n    for (let i = 0; i < dataChunks.length; i++) {\n      const chunk = dataChunks[i];\n      buffer.set(chunk, offset);\n      offset += chunk.byteLength;\n    }\n\n    this._buffer = buffer;\n    this._size = this._buffer.byteLength;\n    this._type = opts.type || '';\n\n    if (/[^\\u0020-\\u007E]/.test(this._type)) {\n      this._type = '';\n    } else {\n      this._type = this._type.toLowerCase();\n    }\n  }\n\n  get size() {\n    return this._size;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  arrayBuffer() {\n    return Promise.resolve(this._buffer);\n  }\n\n  text() {\n    const textDecoder = new TextDecoder();\n    return Promise.resolve(textDecoder.decode(this._buffer));\n  }\n\n  slice(start, end, type) {\n    const slice = this._buffer.slice(start || 0, end || this._buffer.length);\n\n    return new Blob([slice], {\n      type: type\n    });\n  }\n\n  stream() {\n    throw new Error('stream is currently not supported');\n  }\n\n  toString() {\n    return '[object Blob]';\n  }\n\n} // Note: only for use by XHR\n\nBlob.InternalAccessor = class {\n  static getBuffer(blob) {\n    return blob._buffer;\n  }\n\n};\nexport class File extends Blob {\n  constructor(chunks, name, opts = {}) {\n    super(chunks, opts);\n    this[Symbol.toStringTag] = 'File';\n    this._name = name.replace(/\\//g, ':');\n    this._lastModified = opts.lastModified ? new Date(opts.lastModified).valueOf() : Date.now();\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  get lastModified() {\n    return this._lastModified;\n  }\n\n  toString() {\n    return '[object File]';\n  }\n\n}\nexport class FileReader {\n  constructor() {\n    this.EMPTY = 0;\n    this.LOADING = 1;\n    this.DONE = 2;\n    this._listeners = new Map();\n    this[Symbol.toStringTag] = 'FileReader'; //\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n\n  get result() {\n    return this._result;\n  }\n\n  _array2base64(input) {\n    const byteToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    const output = [];\n\n    for (let i = 0; i < input.length; i += 3) {\n      const byte1 = input[i];\n      const haveByte2 = i + 1 < input.length;\n      const byte2 = haveByte2 ? input[i + 1] : 0;\n      const haveByte3 = i + 2 < input.length;\n      const byte3 = haveByte3 ? input[i + 2] : 0;\n      const outByte1 = byte1 >> 2;\n      const outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;\n      let outByte3 = (byte2 & 0x0f) << 2 | byte3 >> 6;\n      let outByte4 = byte3 & 0x3f;\n\n      if (!haveByte3) {\n        outByte4 = 64;\n\n        if (!haveByte2) {\n          outByte3 = 64;\n        }\n      }\n\n      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n    }\n\n    return output.join('');\n  }\n\n  _read(blob, kind) {\n    if (!(blob instanceof Blob)) {\n      throw new TypeError(`Failed to execute '${kind}' on 'FileReader': parameter 1 is not of type 'Blob'.`);\n    }\n\n    this._result = '';\n    setTimeout(() => {\n      this._readyState = this.LOADING;\n      this.emitEvent('load');\n      this.emitEvent('loadend');\n    });\n  }\n\n  emitEvent(eventName, ...args) {\n    if (types.isFunction(this['on' + eventName])) {\n      this['on' + eventName](...args);\n    }\n\n    const handlers = this._listeners.get(eventName) || [];\n    handlers.forEach(handler => {\n      handler(...args);\n    });\n  }\n\n  addEventListener(eventName, handler) {\n    if (['abort', 'error', 'load', 'loadend', 'loadstart', 'progress'].indexOf(eventName) === -1) {\n      throw new Error('Event not supported: ' + eventName);\n    }\n\n    const handlers = this._listeners.get(eventName) || [];\n    handlers.push(handler);\n\n    this._listeners.set(eventName, handlers);\n  }\n\n  removeEventListener(eventName, toDetach) {\n    let handlers = this._listeners.get(eventName) || [];\n    handlers = handlers.filter(handler => handler !== toDetach);\n\n    this._listeners.set(eventName, handlers);\n  }\n\n  readAsDataURL(blob) {\n    this._read(blob, 'readAsDataURL');\n\n    this._result = `data:${blob.type};base64,${this._array2base64(Blob.InternalAccessor.getBuffer(blob))}`;\n  }\n\n  readAsText(blob) {\n    this._read(blob, 'readAsText');\n\n    const textDecoder = new TextDecoder();\n    this._result = textDecoder.decode(Blob.InternalAccessor.getBuffer(blob));\n  }\n\n  readAsArrayBuffer(blob) {\n    this._read(blob, 'readAsArrayBuffer');\n\n    this._result = Blob.InternalAccessor.getBuffer(blob).buffer.slice(0);\n  }\n\n  abort() {//\n  }\n\n  toString() {\n    return '[object FileReader]';\n  }\n\n} //# sourceMappingURL=index.js.map",
    "map": {
        "version": 3,
        "sources": [
            "/Users/william/Projects/opensource/native/examples/nativescript-ng/node_modules/@nativescript/core/xhr/index.js"
        ],
        "names": [
            "http",
            "types",
            "Trace",
            "XMLHttpRequestResponseType",
            "empty",
            "text",
            "json",
            "blob",
            "arraybuffer",
            "XMLHttpRequest",
            "constructor",
            "UNSENT",
            "OPENED",
            "HEADERS_RECEIVED",
            "LOADING",
            "DONE",
            "_responseType",
            "_listeners",
            "Map",
            "_readyState",
            "upload",
            "readyState",
            "responseType",
            "value",
            "Error",
            "responseText",
            "isFunction",
            "_responseTextReader",
            "response",
            "_response",
            "status",
            "_status",
            "statusText",
            "_errorFlag",
            "statuses",
            "_loadResponse",
            "r",
            "statusCode",
            "_headers",
            "headers",
            "_setReadyState",
            "content",
            "toString",
            "contentType",
            "getResponseHeader",
            "mimeType",
            "toLowerCase",
            "finalMimeType",
            "_overrideMimeType",
            "toJSON",
            "toArrayBuffer",
            "Blob",
            "type",
            "emitEvent",
            "_sendFlag",
            "eventName",
            "args",
            "handlers",
            "get",
            "forEach",
            "handler",
            "_setRequestError",
            "error",
            "addEventListener",
            "indexOf",
            "isEnabled",
            "write",
            "categories",
            "Debug",
            "messageType",
            "warn",
            "push",
            "set",
            "removeEventListener",
            "toDetach",
            "filter",
            "open",
            "method",
            "url",
            "async",
            "user",
            "password",
            "isString",
            "_options",
            "abort",
            "send",
            "data",
            "FormData",
            "setRequestHeader",
            "InternalAccessor",
            "getBuffer",
            "ArrayBuffer",
            "request",
            "then",
            "catch",
            "e",
            "header",
            "getAllResponseHeaders",
            "result",
            "i",
            "substr",
            "length",
            "overrideMimeType",
            "mime",
            "_data",
            "append",
            "name",
            "arr",
            "Array",
            "map",
            "encodeURIComponent",
            "join",
            "chunks",
            "opts",
            "Symbol",
            "toStringTag",
            "dataChunks",
            "chunk",
            "_buffer",
            "textEncoder",
            "TextEncoder",
            "encode",
            "DataView",
            "Uint8Array",
            "buffer",
            "slice",
            "isView",
            "String",
            "size",
            "reduce",
            "byteLength",
            "offset",
            "_size",
            "_type",
            "test",
            "arrayBuffer",
            "Promise",
            "resolve",
            "textDecoder",
            "TextDecoder",
            "decode",
            "start",
            "end",
            "stream",
            "File",
            "_name",
            "replace",
            "_lastModified",
            "lastModified",
            "Date",
            "valueOf",
            "now",
            "FileReader",
            "EMPTY",
            "_result",
            "_array2base64",
            "input",
            "byteToCharMap",
            "output",
            "byte1",
            "haveByte2",
            "byte2",
            "haveByte3",
            "byte3",
            "outByte1",
            "outByte2",
            "outByte3",
            "outByte4",
            "_read",
            "kind",
            "TypeError",
            "setTimeout",
            "readAsDataURL",
            "readAsText",
            "readAsArrayBuffer"
        ],
        "mappings": "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",
        "sourcesContent": [
            "import * as http from '../http';\nimport * as types from '../utils/types';\nimport { Trace } from '../trace';\nvar XMLHttpRequestResponseType;\n(function (XMLHttpRequestResponseType) {\n    XMLHttpRequestResponseType.empty = '';\n    XMLHttpRequestResponseType.text = 'text';\n    XMLHttpRequestResponseType.json = 'json';\n    XMLHttpRequestResponseType.blob = 'blob';\n    XMLHttpRequestResponseType.arraybuffer = 'arraybuffer';\n})(XMLHttpRequestResponseType || (XMLHttpRequestResponseType = {}));\nexport class XMLHttpRequest {\n    constructor() {\n        this.UNSENT = 0;\n        this.OPENED = 1;\n        this.HEADERS_RECEIVED = 2;\n        this.LOADING = 3;\n        this.DONE = 4;\n        this._responseType = '';\n        this._listeners = new Map();\n        this._readyState = this.UNSENT;\n    }\n    get upload() {\n        return this;\n    }\n    get readyState() {\n        return this._readyState;\n    }\n    get responseType() {\n        return this._responseType;\n    }\n    set responseType(value) {\n        if (value === XMLHttpRequestResponseType.empty || value in XMLHttpRequestResponseType) {\n            this._responseType = value;\n        }\n        else {\n            throw new Error(`Response type of '${value}' not supported.`);\n        }\n    }\n    get responseText() {\n        if (this._responseType !== XMLHttpRequestResponseType.empty && this._responseType !== XMLHttpRequestResponseType.text) {\n            throw new Error(\"Failed to read the 'responseText' property from 'XMLHttpRequest': \" + \"The value is only accessible if the object's 'responseType' is '' or 'text' \" + `(was '${this._responseType}').`);\n        }\n        if (types.isFunction(this._responseTextReader)) {\n            return this._responseTextReader();\n        }\n        return '';\n    }\n    get response() {\n        if (this._responseType === XMLHttpRequestResponseType.empty || this._responseType === XMLHttpRequestResponseType.text) {\n            if (this._readyState !== this.LOADING && this._readyState !== this.DONE) {\n                return '';\n            }\n            else {\n                return this._response;\n            }\n        }\n        else {\n            if (this._readyState !== this.DONE) {\n                return null;\n            }\n            else {\n                return this._response;\n            }\n        }\n    }\n    get status() {\n        return this._status;\n    }\n    get statusText() {\n        if (this._readyState === this.UNSENT || this._readyState === this.OPENED || this._errorFlag) {\n            return '';\n        }\n        return statuses[this._status];\n    }\n    _loadResponse(r) {\n        this._status = r.statusCode;\n        this._headers = r.headers;\n        this._setReadyState(this.HEADERS_RECEIVED);\n        this._setReadyState(this.LOADING);\n        this._responseTextReader = () => r.content.toString();\n        const contentType = this.getResponseHeader('Content-Type');\n        const mimeType = (contentType && contentType.toLowerCase()) || 'text/xml';\n        const finalMimeType = this._overrideMimeType || mimeType;\n        if (this._responseType === XMLHttpRequestResponseType.json) {\n            this._response = r.content.toJSON();\n        }\n        else if (this._responseType === XMLHttpRequestResponseType.text || this._responseType === XMLHttpRequestResponseType.empty) {\n            this._response = this.responseText;\n        }\n        else if (this._responseType === XMLHttpRequestResponseType.arraybuffer) {\n            this._response = r.content.toArrayBuffer();\n        }\n        else if (this._responseType === XMLHttpRequestResponseType.blob) {\n            this._response = new Blob([r.content.toArrayBuffer()], {\n                type: finalMimeType,\n            });\n        }\n        this.emitEvent('progress');\n        this._sendFlag = false;\n        this._setReadyState(this.DONE);\n    }\n    emitEvent(eventName, ...args) {\n        if (types.isFunction(this['on' + eventName])) {\n            this['on' + eventName](...args);\n        }\n        const handlers = this._listeners.get(eventName) || [];\n        handlers.forEach((handler) => {\n            handler(...args);\n        });\n    }\n    _setReadyState(value) {\n        if (this._readyState !== value) {\n            this._readyState = value;\n            this.emitEvent('readystatechange');\n        }\n        if (this._readyState === this.DONE) {\n            this.emitEvent('load');\n            this.emitEvent('loadend');\n        }\n    }\n    _setRequestError(eventName, error) {\n        this._readyState = this.DONE;\n        this._response = error;\n        this.emitEvent('readystatechange');\n        this.emitEvent(eventName, error);\n        this.emitEvent('loadend');\n    }\n    addEventListener(eventName, handler) {\n        if (['abort', 'error', 'load', 'loadend', 'loadstart', 'progress', 'readystatechange'].indexOf(eventName) === -1) {\n            if (Trace.isEnabled()) {\n                Trace.write('XHR Event not supported: ' + eventName, Trace.categories.Debug, Trace.messageType.warn);\n            }\n        }\n        const handlers = this._listeners.get(eventName) || [];\n        handlers.push(handler);\n        this._listeners.set(eventName, handlers);\n    }\n    removeEventListener(eventName, toDetach) {\n        let handlers = this._listeners.get(eventName) || [];\n        handlers = handlers.filter((handler) => handler !== toDetach);\n        this._listeners.set(eventName, handlers);\n    }\n    open(method, url, async, user, password) {\n        if (types.isString(method) && types.isString(url)) {\n            this._options = { url: url, method: method };\n            this._options.headers = {};\n            if (types.isString(user)) {\n                this._options.headers['user'] = user;\n            }\n            if (types.isString(password)) {\n                this._options.headers['password'] = password;\n            }\n            this._setReadyState(this.OPENED);\n        }\n    }\n    abort() {\n        this._response = null;\n        this._responseTextReader = null;\n        this._headers = null;\n        this._status = null;\n        if ((this._readyState === this.OPENED && this._sendFlag) || this._readyState === this.HEADERS_RECEIVED || this._readyState === this.LOADING) {\n            this._errorFlag = true;\n            this._sendFlag = false;\n            this._setRequestError('abort');\n        }\n        if (this._readyState === this.DONE) {\n            this._readyState = this.UNSENT;\n        }\n    }\n    send(data) {\n        this._errorFlag = false;\n        this._response = null;\n        this._responseTextReader = null;\n        this._headers = null;\n        this._status = null;\n        if (this._readyState !== this.OPENED || this._sendFlag) {\n            throw new Error(\"Failed to execute 'send' on 'XMLHttpRequest': \" + \"The object's state must be OPENED.\");\n        }\n        if (types.isString(data) && this._options.method !== 'GET') {\n            //The Android Java HTTP lib throws an exception if we provide a\n            //a request body for GET requests, so we avoid doing that.\n            //Browser implementations silently ignore it as well.\n            this._options.content = data;\n        }\n        else if (data instanceof FormData) {\n            this._options.content = data.toString();\n        }\n        else if (data instanceof Blob) {\n            this.setRequestHeader('Content-Type', data.type);\n            this._options.content = Blob.InternalAccessor.getBuffer(data);\n        }\n        else if (data instanceof ArrayBuffer) {\n            this._options.content = data;\n        }\n        this._sendFlag = true;\n        this.emitEvent('loadstart');\n        http\n            .request(this._options)\n            .then((r) => {\n            if (!this._errorFlag && this._sendFlag) {\n                this._loadResponse(r);\n            }\n        })\n            .catch((e) => {\n            this._errorFlag = true;\n            this._sendFlag = false;\n            this._setRequestError('error', e);\n        });\n    }\n    setRequestHeader(header, value) {\n        if (this._readyState !== this.OPENED || this._sendFlag) {\n            throw new Error(\"Failed to execute 'setRequestHeader' on 'XMLHttpRequest': \" + \"The object's state must be OPENED.\");\n        }\n        if (types.isString(header) && types.isString(value)) {\n            this._options.headers[header] = value;\n        }\n    }\n    getAllResponseHeaders() {\n        if (this._readyState < 2 || this._errorFlag) {\n            return '';\n        }\n        let result = '';\n        for (const i in this._headers) {\n            result += i + ': ' + this._headers[i] + '\\r\\n';\n        }\n        return result.substr(0, result.length - 2);\n    }\n    getResponseHeader(header) {\n        if (types.isString(header) && this._readyState > 1 && this._headers && !this._errorFlag) {\n            header = header.toLowerCase();\n            for (const i in this._headers) {\n                if (i.toLowerCase() === header) {\n                    return this._headers[i];\n                }\n            }\n        }\n        return null;\n    }\n    overrideMimeType(mime) {\n        if (this._readyState === this.LOADING || this._readyState === this.DONE) {\n            throw new Error(\"Failed to execute 'overrideMimeType' on 'XMLHttpRequest': \" + 'MimeType cannot be overridden when the state is LOADING or DONE.');\n        }\n        this._overrideMimeType = mime;\n    }\n}\nconst statuses = {\n    100: 'Continue',\n    101: 'Switching Protocols',\n    200: 'OK',\n    201: 'Created',\n    202: 'Accepted',\n    203: 'Non - Authoritative Information',\n    204: 'No Content',\n    205: 'Reset Content',\n    206: 'Partial Content',\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Found',\n    303: 'See Other',\n    304: 'Not Modified',\n    305: 'Use Proxy',\n    307: 'Temporary Redirect',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    405: 'Method Not Allowed',\n    406: 'Not Acceptable',\n    407: 'Proxy Authentication Required',\n    408: 'Request Timeout',\n    409: 'Conflict',\n    410: 'Gone',\n    411: 'Length Required',\n    412: 'Precondition Failed',\n    413: 'Request Entity Too Large',\n    414: 'Request - URI Too Long',\n    415: 'Unsupported Media Type',\n    416: 'Requested Range Not Satisfiable',\n    417: 'Expectation Failed',\n    500: 'Internal Server Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Gateway Timeout',\n    505: 'HTTP Version Not Supported',\n};\nexport class FormData {\n    constructor() {\n        this._data = new Map();\n    }\n    append(name, value) {\n        this._data.set(name, value);\n    }\n    toString() {\n        const arr = new Array();\n        this._data.forEach(function (value, name, map) {\n            arr.push(`${encodeURIComponent(name)}=${encodeURIComponent(value)}`);\n        });\n        return arr.join('&');\n    }\n}\nexport class Blob {\n    constructor(chunks = [], opts = {}) {\n        this[Symbol.toStringTag] = 'Blob';\n        const dataChunks = [];\n        for (const chunk of chunks) {\n            if (chunk instanceof Blob) {\n                dataChunks.push(chunk._buffer);\n            }\n            else if (typeof chunk === 'string') {\n                const textEncoder = new TextEncoder();\n                dataChunks.push(textEncoder.encode(chunk));\n            }\n            else if (chunk instanceof DataView) {\n                dataChunks.push(new Uint8Array(chunk.buffer.slice(0)));\n            }\n            else if (chunk instanceof ArrayBuffer || ArrayBuffer.isView(chunk)) {\n                dataChunks.push(new Uint8Array(ArrayBuffer.isView(chunk) ? chunk.buffer.slice(0) : chunk.slice(0)));\n            }\n            else {\n                const textEncoder = new TextEncoder();\n                dataChunks.push(textEncoder.encode(String(chunk)));\n            }\n        }\n        const size = dataChunks.reduce((size, chunk) => size + chunk.byteLength, 0);\n        const buffer = new Uint8Array(size);\n        let offset = 0;\n        for (let i = 0; i < dataChunks.length; i++) {\n            const chunk = dataChunks[i];\n            buffer.set(chunk, offset);\n            offset += chunk.byteLength;\n        }\n        this._buffer = buffer;\n        this._size = this._buffer.byteLength;\n        this._type = opts.type || '';\n        if (/[^\\u0020-\\u007E]/.test(this._type)) {\n            this._type = '';\n        }\n        else {\n            this._type = this._type.toLowerCase();\n        }\n    }\n    get size() {\n        return this._size;\n    }\n    get type() {\n        return this._type;\n    }\n    arrayBuffer() {\n        return Promise.resolve(this._buffer);\n    }\n    text() {\n        const textDecoder = new TextDecoder();\n        return Promise.resolve(textDecoder.decode(this._buffer));\n    }\n    slice(start, end, type) {\n        const slice = this._buffer.slice(start || 0, end || this._buffer.length);\n        return new Blob([slice], { type: type });\n    }\n    stream() {\n        throw new Error('stream is currently not supported');\n    }\n    toString() {\n        return '[object Blob]';\n    }\n}\n// Note: only for use by XHR\nBlob.InternalAccessor = class {\n    static getBuffer(blob) {\n        return blob._buffer;\n    }\n};\nexport class File extends Blob {\n    constructor(chunks, name, opts = {}) {\n        super(chunks, opts);\n        this[Symbol.toStringTag] = 'File';\n        this._name = name.replace(/\\//g, ':');\n        this._lastModified = opts.lastModified ? new Date(opts.lastModified).valueOf() : Date.now();\n    }\n    get name() {\n        return this._name;\n    }\n    get lastModified() {\n        return this._lastModified;\n    }\n    toString() {\n        return '[object File]';\n    }\n}\nexport class FileReader {\n    constructor() {\n        this.EMPTY = 0;\n        this.LOADING = 1;\n        this.DONE = 2;\n        this._listeners = new Map();\n        this[Symbol.toStringTag] = 'FileReader';\n        //\n    }\n    get readyState() {\n        return this._readyState;\n    }\n    get result() {\n        return this._result;\n    }\n    _array2base64(input) {\n        const byteToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        const output = [];\n        for (let i = 0; i < input.length; i += 3) {\n            const byte1 = input[i];\n            const haveByte2 = i + 1 < input.length;\n            const byte2 = haveByte2 ? input[i + 1] : 0;\n            const haveByte3 = i + 2 < input.length;\n            const byte3 = haveByte3 ? input[i + 2] : 0;\n            const outByte1 = byte1 >> 2;\n            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\n            let outByte4 = byte3 & 0x3f;\n            if (!haveByte3) {\n                outByte4 = 64;\n                if (!haveByte2) {\n                    outByte3 = 64;\n                }\n            }\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n        }\n        return output.join('');\n    }\n    _read(blob, kind) {\n        if (!(blob instanceof Blob)) {\n            throw new TypeError(`Failed to execute '${kind}' on 'FileReader': parameter 1 is not of type 'Blob'.`);\n        }\n        this._result = '';\n        setTimeout(() => {\n            this._readyState = this.LOADING;\n            this.emitEvent('load');\n            this.emitEvent('loadend');\n        });\n    }\n    emitEvent(eventName, ...args) {\n        if (types.isFunction(this['on' + eventName])) {\n            this['on' + eventName](...args);\n        }\n        const handlers = this._listeners.get(eventName) || [];\n        handlers.forEach((handler) => {\n            handler(...args);\n        });\n    }\n    addEventListener(eventName, handler) {\n        if (['abort', 'error', 'load', 'loadend', 'loadstart', 'progress'].indexOf(eventName) === -1) {\n            throw new Error('Event not supported: ' + eventName);\n        }\n        const handlers = this._listeners.get(eventName) || [];\n        handlers.push(handler);\n        this._listeners.set(eventName, handlers);\n    }\n    removeEventListener(eventName, toDetach) {\n        let handlers = this._listeners.get(eventName) || [];\n        handlers = handlers.filter((handler) => handler !== toDetach);\n        this._listeners.set(eventName, handlers);\n    }\n    readAsDataURL(blob) {\n        this._read(blob, 'readAsDataURL');\n        this._result = `data:${blob.type};base64,${this._array2base64(Blob.InternalAccessor.getBuffer(blob))}`;\n    }\n    readAsText(blob) {\n        this._read(blob, 'readAsText');\n        const textDecoder = new TextDecoder();\n        this._result = textDecoder.decode(Blob.InternalAccessor.getBuffer(blob));\n    }\n    readAsArrayBuffer(blob) {\n        this._read(blob, 'readAsArrayBuffer');\n        this._result = Blob.InternalAccessor.getBuffer(blob).buffer.slice(0);\n    }\n    abort() {\n        //\n    }\n    toString() {\n        return '[object FileReader]';\n    }\n}\n//# sourceMappingURL=index.js.map"
        ]
    },
    "metadata": {},
    "sourceType": "module"
}
